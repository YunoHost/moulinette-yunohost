CAN_BIND=${CAN_BIND:-1}

# Mark a file or a directory for backup
# 
# Note: this helper could be used in backup hook or in backup script inside an
# app package
#
# Details: ynh_backup writes SRC and the relative DEST into a CSV file. Then,
# it try to bind or symlink the DEST to the SRC, if it isn't possible it just
# do a copy.  
# 
# If DEST is ended by a slash it complete this path with the basename of SRC.
#
# usage: ynh_backup src [dest [is_big [arg]]]
# | arg: src - file or directory to bind or symlink or copy. it shouldn't be in
# the backup dir. 
# | arg: dest - destination file or directory inside the
# backup dir
# | arg: is_big - 1 to indicate data are big (mail, video, image ...)
# | arg: arg - Deprecated arg
ynh_backup() {
    local SRC_PATH=$1
    local DEST_PATH=${2:-}
    local IS_BIG=${3:-0}

    # validate arguments
    [[ -e "${SRC_PATH}" ]] || {
        echo "Source path '${SRC_PATH}' does not exist" >&2
        return 1
    }

    # Transform SRCPATH as absolute path
    SRC_PATH="$(realpath $SRC_PATH)"

    # If unspecified DESTPATH=SRCPATH
    [[ -z "$DEST_PATH" ]] && \
        DEST_PATH="${SRC_PATH#/}"

    # Transform DEST_PATH into relative path
    [[ "${DEST_PATH:0:1}" == "/" ]] \
        && DEST_PATH="${DEST_PATH#$YNH_CWD/}"

    [[ "${DEST_PATH:0:1}" == "/" ]] \
        && DEST_PATH="${DEST_PATH#/}"

    # Complete DEST_PATH if ended by a /
    [[ "${DEST_PATH: -1}" == "/" ]] \
        &&  DEST_PATH="${DEST_PATH}/$(basename $SRC_PATH)"

    # Check if DEST_PATH already exists in tmp archive
    [[ ! -e "${DEST_PATH}" ]] || {
        echo "Destination path '${DEST_PATH}' already exist" >&2
        return 1
    }

    # Write file to backup into backup_list
    local REL_DIR="${YNH_CWD#$YNH_BACKUP_DIR}"
    REL_DIR="${REL_DIR%/}/"
    local SRC=$(echo "${SRC_PATH}" | sed -r 's/"/\"\"/g')
    local DEST=$(echo "${REL_DIR}${DEST_PATH}" | sed -r 's/"/\"\"/g')
    DEST="${DEST#/}"
    echo "\"${SRC}\",\"${DEST}\"" | sudo tee --append ${YNH_BACKUP_CSV} > /dev/null

    sudo mkdir -p $(dirname "${DEST_PATH}")
}

# Restore all files linked to the restore hook or to the restore app script
#
# usage: ynh_restore
#
ynh_restore () {
    local REL_DIR="${YNH_CWD#$YNH_BACKUP_DIR/}"
    REL_DIR="${REL_DIR%/}/"
    sudo grep -ohP $'^\".*\",\"$REL_DIR.*\"$' ${YNH_BACKUP_CSV} | \
    while read line; do
        local ORIGIN_PATH=$(echo $line | grep -ohP "^\"\K.*(?=\",\".*\"$)")
        local ARCHIVE_PATH=$(echo $line | grep -ohP "^\".*\",\"\K.*(?=\"$)")
        ynh_restore_file $ARCHIVE_PATH $ORIGIN_PATH
    done
}

_get_archive_path () {
    sudo python -c "
import sys
import csv
with open(sys.argv[1], 'r') as backup_file:
    backup_csv = csv.DictReader(backup_file, fieldnames=['source', 'dest'])
    for row in backup_csv:
        if row['source']==sys.argv[2]:
            print row['dest']
            sys.exit(0)
    raise Exception()" $1 $2
    return $?
}
# Restore a file or a directory 
#
# Use the registered path in backup_list by ynh_backup to restore the file at
# the good place.
#
# usage: ynh_restore_file ORIGIN_PATH [ DEST_PATH ]
# | arg: ORIGIN_PATH - Path where was located the file or the directory before
# to be backuped or relative path to $YNH_CWD where it is located in the backup archive
# | arg: DEST_PATH   - Path where restore the file or the dir, if unspecified,
# the destination will be ORIGIN_PATH or if the ORIGIN_PATH doesn't exist in
# the archive, the destination will be searched into backup.csv
#
ynh_restore_file () {
    local ORIGIN_PATH=/${1#/}
    local ARCHIVE_PATH=$YNH_CWD${ORIGIN_PATH}
    # Default value for DEST_PATH = /$ORIGIN_PATH
    local DEST_PATH=${2:-$ORIGIN_PATH}
    
    # If ARCHIVE_PATH doesn't exist, search for a corresponding path in CSV
    sudo test -e $ARCHIVE_PATH
    if [ $? -ne 0 ]; then
        ARCHIVE_PATH=$YNH_BACKUP_DIR/$(_get_archive_path ${YNH_BACKUP_CSV} $ORIGIN_PATH)
    fi
    
    # Restore ORIGIN_PATH into DEST_PATH
    if [[ -d ${ARCHIVE_PATH} ]]; then
       sudo mkdir -p $DEST_PATH
       ARCHIVE_PATH="${ARCHIVE_PATH}/."
    else
       sudo mkdir -p $(dirname $DEST_PATH)
    fi
    sudo cp -a "$ARCHIVE_PATH" "${DEST_PATH}"
    
}

# Deprecated helper since it's a dangerous one!
ynh_bind_or_cp() {
    local AS_ROOT=${3:-0}
    local NO_ROOT=0
    [[ "${AS_ROOT}" = "1" ]] || NO_ROOT=1
    echo "This helper is deprecated, you should use ynh_backup instead" >&2
    ynh_backup "$1" "$2" 1
}

# Create a directory under /tmp
#
# Deprecated helper
#
# usage: ynh_mkdir_tmp
# | ret: the created directory path
ynh_mkdir_tmp() {
    echo "The helper ynh_mkdir_tmp is deprecated." >&2
    echo "You should use 'mktemp -d' instead and manage permissions \
properly with chmod/chown." >&2
    local TMP_DIR=$(mktemp -d)

    # Give rights to other users could be a security risk.
    # But for retrocompatibility we need it. (This helpers is deprecated)
    chmod 755 $TMP_DIR
    echo $TMP_DIR
}
