CAN_BIND=${CAN_BIND:-1}

# Mark a file or a directory for backup
# Note: currently, SRCPATH will be copied or binded to DESTPATH
#
# usage: ynh_backup srcdir destdir to_bind no_root
# | arg: srcdir - directory to bind or copy
# | arg: destdir - mountpoint or destination directory
# | arg: to_bind - 1 to bind mounting the directory if possible
# | arg: no_root - 1 to execute commands as current user
ynh_backup() {
    local SRCPATH=$1
    local DESTPATH=$2
    local TO_BIND=${3:-0}
    local SUDO_CMD="sudo"
    [[ "${4:-}" = "1" ]] && SUDO_CMD=

    # validate arguments
    [[ -e "${SRCPATH}" ]] || {
        echo "Source path '${DESTPATH}' does not exist" >&2
        return 1
    }

    # prepend the backup directory
    [[ -n "${YNH_APP_BACKUP_DIR:-}" && "${DESTPATH:0:1}" != "/" ]] \
        && DESTPATH="${YNH_APP_BACKUP_DIR}/${DESTPATH}"
    [[ ! -e "${DESTPATH}" ]] || {
        echo "Destination path '${DESTPATH}' already exist" >&2
        return 1
    }

    # attempt to bind mounting the directory
    if [[ "${CAN_BIND}" = "1" && "${TO_BIND}" = "1" ]]; then
        eval $SUDO_CMD mkdir -p "${DESTPATH}"

        if sudo mount --rbind "${SRCPATH}" "${DESTPATH}"; then
            # try to remount destination directory as read-only
            sudo mount -o remount,ro,bind "${SRCPATH}" "${DESTPATH}" \
              || true
            return 0
        else
            CAN_BIND=0
            echo "Bind mounting seems to be disabled on your system."
            echo "You have maybe to check your apparmor configuration."
        fi

        # delete mountpoint directory safely
        mountpoint -q "${DESTPATH}" && sudo umount -R "${DESTPATH}"
        eval $SUDO_CMD rm -rf "${DESTPATH}"
    fi

    # ... or just copy the directory
    eval $SUDO_CMD mkdir -p $(dirname "${DESTPATH}")
    eval $SUDO_CMD cp -a "${SRCPATH}" "${DESTPATH}"
}

# Deprecated helper since it's a dangerous one!
ynh_bind_or_cp() {
    local AS_ROOT=${3:-0}
    local NO_ROOT=0
    [[ "${AS_ROOT}" = "1" ]] || NO_ROOT=1
    echo "This helper is deprecated, you should use ynh_backup instead" >&2
    ynh_backup "$1" "$2" 1 "$NO_ROOT"
}

# Create a directory under /tmp
#
# Deprecated helper
#
# usage: ynh_mkdir_tmp
# | ret: the created directory path
ynh_mkdir_tmp() {
    echo "This helper is deprecated, you should use 'mktemp -d' instead." >&2
    mktemp -d
}

# Prevent suppression of a important parent dir
# Remove a directory with some variables into the path.
# Each variable are checked, if a variable are empty, the suppression are cancelled.
#
# usage: ynh_safe_remove 'path_to_remove'
# | arg: path_to_remove - directory to remove. The path of directory need to be placed between simple quotes
ynh_safe_remove() {
	chaine="$1"
	no_var=0
	while (echo "$chaine" | grep -q '\$')	# Boucle tant qu'il y a des $ dans la chaine
	do
		no_var=1
		global_var=$(echo "$chaine" | cut -d '$' -f 2)	# Isole la première variable trouvée.
		only_var=\$$(expr "$global_var" : '\([A-Za-z0-9_]*\)')	# Isole complètement la variable en ajoutant le $ au début et en gardant uniquement le nom de la variable. Se débarrasse surtout du / et d'un éventuel chemin derrière.
		real_var=$(eval "echo ${only_var}")		# `eval "echo ${var}` permet d'interpréter une variable contenue dans une variable.
		if test -z "$real_var"; then
			echo "Variable $only_var is empty, suppression of $chaine cancelled."
			return 1
		fi
		chaine=$(echo "$chaine" | sed "s@$only_var@$real_var@")	# remplace la variable par sa valeur dans la chaine.
	done
	if [ "$no_var" -eq 1 ]
	then
		echo "Delete directory $chaine"
 		sudo rm -r "$chaine"
		return 0
	else
		echo "No detected variable."
		return 1
	fi
}
